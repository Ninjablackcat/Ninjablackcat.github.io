<!DOCTYPE html>
<html lang="en"> <!-- English website -->
    <head>
        <!-- External css link -->
        <link rel="stylesheet" href="css styles/default.css">
        <!-- Meta style -->
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <!-- Webpage title -->
        <title>NBC's Website | University Projects</title>
        <!-- Favicon -->
        <link rel="shortcut icon" href="webpage images/favicon16.ico" sizes="16x16" type="image/x-icon">

        <link rel="icon" href="webpage images/favicon16.ico" sizes="16x16" type="image/x-icon">

    </head>
    <body>

        <!-- Navigation to other pages -->
        <div id="navBar">
            <a href="index.html" class="leftmost">Home</a>
            <a href="university projects.html" class="active">University Projects</a>
            <a href="personal projects.html">Personal Projects</a>
            <a href="achievements.html">Achievements</a>
            <a href="about.html">About</a>
            <a href="contacts.html">Contacts</a>
            <a href="svgCanvasTest.html">SVG Text Rain</a>
        </div>


        <!-- Contents -->
        <div id="title">
            <div class="edgeSpacer">
                <h1>Projects</h1>
            </div>
        </div>

        <div id="primeContent">
            <div class="edgeSpacer">
                <div class="project">
                    <h2>PLC Elevator</h2>
                    <p>
                        Goal of this project was to get model PLC controlled elevators to operate similarly to real elevators.<br>
                        This included accounting for the demand on each floor to try minimise the wait time for users.
                    </p>
                    <p>Below are snippets of the code used.</p>
                    <img src="webpage images/university projects/PLC Elevator Ladder Logic Example.png" alt="Example of Ladder logic code for indicating elevator direction.">
                    <img src="webpage images/university projects/PLC Elevator Section List.png" alt="List of sections for elevator code.">

                </div>

                <div class="project">
                    <h2>Robocup</h2>
                    <p>
                        My primary objective for the robot was developing the navigation method for the robot. The robot would navigate around an arena with walls as obstacles, and metal weights as "points" to be collected.
                        <br>An ultrasonic sensor array was used to collect the data, as they had sufficient range to see obstacles ahead, and were more accurate than the IR sensors available - which had even longer range.
                        <br>At the time I was intending to essentually build a map of the arena while collecting data points. Thus observing to the other side of the arena would be redundant, especially with the opponents robot also in the arena.
                        <br>
                    </p>
                    <img src="webpage images/university projects/Robocup sensor array.jpg" alt="Ultrasonic sensor array, rotated by servos." width="800">
                    <br>
                    <br>
                    <p>
                        One main challenge was that the supplied code for the ultrasonic sensors was "blocking" - that is, the microcontroller could not do any tasks until the ultrasonic sensor would return a response.
                        <br>Given that the sensors had a maximum range of 4m - resulting in a total travel distance of 8 meters for the signal - each measurement could take up to 23ms.
                        <br>While most of the obstacles are fairly large, one could do significantly larger changes in angle with the servos when rotating the sensor arrays.

                        <br>I was not aware of any methods such as a grid map at the time, so I was limiting the amount of data points collected to 2000.
                        <br>Then using a circular buffer to overwrite old data points. This ensured that the amount of time to process the data for the robot's direction of travel would not impact it's performance.

                    </p>
                    <p>
                        Visualised in Processing, as Arduino didn't have a method to plot x,y data. This required using serial communication from the microcontroller to the desktop.
                        <br>Method for detecting weights was based on comparing a group of points collected by the bottom-most sensor.
                        <br>If the points collected were consistent for the appearance of a weight, then it would be indicated by a yellow square.
                        <br>Obstacles were detected based on both sensors measuring the same output, and indicated by a red dot.
                        <br>Robot forward direction indicated by the blue line from the white dot.
                    </p>
                    <img src="webpage images/university projects/Robocup visualising data with robot direction.jpg" alt="Plot of data indicating obstacles (red) and targets (yellow) and robot (white/blue)." width="400">
                </div>

                <div class="project">
                    <h2>Wacky Races</h2>
                    <p>This required the use of data sheets to determine which components required which pins of the microcontroller chip, power, ground ect.
                    To ensure easy debugging, essentially any possible wire going to different parts of the board was given its own testpad to ensure easy debugging. This also included every ground trace to different components.
                    <br>This paid off as compared to the other pair within our group working on the "wacky hat", who only used a few test pads.
                    They found it a hassle to try and debug their board later and admitted that they should have done the same thing, despite it initially being a group joke during the process.
                    </p>
                    <embed class="pdf" src="webpage images/university projects/PCB Schematic.pdf#view=FitH" alt="Schematic for PCB.">
                    <br>
                    <br>
                    <p>The schematic for the PCB layout was then produced. While there is no right way to construct the PCB - just that the microcontroller and a few of the required components had specific spots for pasting later on.
                    There are several aspects to try optimise. For example to reduce noise, any transitions between planes should be as close to the pins of the connecting devices.
                    Sometimes this is not achieveable, so any high frequency signals need to have a higher priority for this instead. It is a very careful balancing act.
                    </p>
                    <img src="webpage images/university projects/PCB Layout - partway.png" alt="Sample of some of the PCB construction.">
                    <br>
                    <br>
                    <p>The final PCB that was produced had a lot of things shifted around to allow for as much flexibility as possible. This was in case we wanted to implement any "dastardly stuff" within the rules of the competition.
                    While we didn't end up implementing any such things, it allowed for the maximum potential use of the board.
                    </p>
                    <img src="webpage images/university projects/Final Racer PCB.png" alt="Final Racer PCB.">
                    <p> Once the PCB was ordered and arrived, all of the components needed to be added to the board. This was done using a pick and place machine, and then soldered where required.
                    </p>
                    <p>There was one key issue with the board that required rework. The major one being that the nSleep pin of the PWM H-bridge for driving the motors was connected to ground.
                    This was originally connected to the microcontroller, however we were advised on our initial submission of the board that we should instead be able to change whether power is supplied to the chip, and connect nSleep to ground.
                    This mistake required lifting the nSleep leg off of the PCB, which caused it to break. We managed to somehow get around this by soldering a wire where the leg was, and by luck it managed to stay powered.
                    This was up until the competition day, where when transitioning from a platform to a rotating plank, the racer fell off, and the solder broke off. It then refused to resolder to the chip.
                    Overall this was a very fun project though even with it's challenges.
                    </p>
                </div>
            </div>

        </div>

        <script>
            //Credit: https://github.com/Rudxain/RGB-digital-rain?tab=readme-ov-file for inspiration,
            //Credit: https://codepen.io/gnsp/pen/vYBQZJm for general method of implementation

            var body = document.body,
                html = document.documentElement; // Credit: https://stackoverflow.com/questions/1145850/how-to-get-height-of-entire-document-with-javascript for fixing size of svg
            //Math.max(body.scrollWidth, body.offsetWidth, html.clientWidth, html.scrollWidth, html.offsetWidth);
            //Get webpage size
            var pageWidth = Math.max(body.scrollWidth, body.offsetWidth, html.clientWidth, html.scrollWidth, html.offsetWidth);
            var pageHeight = html.clientHeight; //Is in absolute position, so just need the screen height.

            //console.log(body.scrollHeight);
            //console.log(body.offsetHeight)
            //console.log(html.clientHeight)
            //console.log(html.scrollHeight)
            //console.log(html.offsetHeight)

            //Parameters
            const columnWidth = 40;
            const fontSize = 16;
            const fallSpeed = fontSize;

            // Text Rain fall update| 100 - 300ms, in 25ms increments
            //Performance issues can occur for this to go slower than intended!
            const timeStepSizeMS = 25;
            const textRainUpdateRangeMS = 200;
            const textRainUpdateminMS = 100;
            const trailMSIncrement = timeStepSizeMS;
            const minTrail = 1;

            const columnCount = Math.floor(pageWidth / columnWidth) + 2; //Ensure at least two text columns...
            var twoDTextRainArray = Array(columnCount);
            var textRainLengthsArray = Array(columnCount); // Keeping track of array lengths for trails.

            //Create svg canvas
            var svgTextRain = document.createElementNS("http://www.w3.org/2000/svg", "svg",);
            svgTextRain.classList.add("textRain") //Set to use external css

            svgTextRain.setAttribute('width', pageWidth);
            svgTextRain.setAttribute('height', pageHeight);
            var svgTextRainNS = svgTextRain.namespaceURI;

            //Black background
            var rect = document.createElementNS(svgTextRainNS, 'rect');
            rect.setAttribute('x', 0);
            rect.setAttribute('y', 0);
            rect.setAttribute('width', pageWidth);
            rect.setAttribute('height', pageHeight);
            rect.setAttribute('fill', '#000000');

            svgTextRain.appendChild(rect);
            document.body.appendChild(svgTextRain);



            //Initialise the text rain leaders
            var index = 0

            for (index; index < columnCount; index++) {
                //Get leader attributes to determine trail length
                //Set fall update time (ms)
                var fallUpdateMs = Math.round((Math.random() * textRainUpdateRangeMS / timeStepSizeMS)) * timeStepSizeMS + textRainUpdateminMS;
                //console.log(fallUpdateMs)

                //Create array based on fall speed.
                var trailLength = Math.floor(((textRainUpdateRangeMS + textRainUpdateminMS) - fallUpdateMs) / trailMSIncrement) + minTrail;
                //console.log(trailLength)

                textRainLengthsArray[index] = trailLength + 1; // Trail plus leader
                twoDTextRainArray[index] = Array(trailLength + 1);

                //Generate leader.
                //Create object
                twoDTextRainArray[index][0] = document.createElementNS(svgTextRainNS, 'text');
                //Assign object parameters
                //Initial Position
                twoDTextRainArray[index][0].setAttribute('x', (columnWidth * index) + columnWidth / 8);
                twoDTextRainArray[index][0].setAttribute('y', Math.floor(Math.random() * -pageHeight * 2));
                //twoDTextRainArray[index][0].setAttribute('y', 200); //Testing

                //Font details
                twoDTextRainArray[index][0].setAttribute('fill', '#ffffff');
                //twoDTextRainArray[index].setAttribute('stroke', '#ffffff'); //Makes them bold
                twoDTextRainArray[index][0].setAttribute('font-size', fontSize.toString());
                //Contents - randomised
                twoDTextRainArray[index][0].textContent = String.fromCharCode(Math.floor(Math.random() * 93) + 1);
                //Assign fall attribute.
                twoDTextRainArray[index][0].setAttribute('fallUpdateMS', fallUpdateMs);
                twoDTextRainArray[index][0].setAttribute('idleTimeMS', 0);

                //Generate trail
                var trailIndex = 1;
                for (trailIndex; trailIndex < textRainLengthsArray[index]; trailIndex++) {
                    //Generate trail text element
                    twoDTextRainArray[index][trailIndex] = document.createElementNS(svgTextRainNS, 'text');
                    //Set attributes similar to leader...
                    var trailX = twoDTextRainArray[index][0].getAttribute('x') * 1;
                    var trailY = twoDTextRainArray[index][0].getAttribute('y') * 1 - (trailIndex * fallSpeed);

                    twoDTextRainArray[index][trailIndex].setAttribute('x', trailX);
                    twoDTextRainArray[index][trailIndex].setAttribute('y', trailY);
                    //Font details
                    twoDTextRainArray[index][trailIndex].setAttribute('fill', '#ffffff');
                    //twoDTextRainArray[index][trailIndex].setAttribute('stroke', '#ffffff'); //Makes them bold
                    twoDTextRainArray[index][trailIndex].setAttribute('font-size', fontSize.toString());
                    var textOpacity = (textRainLengthsArray[index] - trailIndex) / textRainLengthsArray[index]
                    twoDTextRainArray[index][trailIndex].setAttribute('fill-opacity', textOpacity.toString());
                    //twoDTextRainArray[index][trailIndex].setAttribute('stroke-opacity', textOpacity.toString()); //Fades outline
                    //Contents - randomised, not same as leader!
                    twoDTextRainArray[index][trailIndex].textContent = String.fromCharCode(Math.floor(Math.random() * 93) + 1);

                    //Will update position based on text ahead - done based on order within function!
                    //twoDTextRainArray[index][trailIndex].setAttribute('nextY', twoDTextRainArray[index][trailIndex-1].getAttribute('y')); // Redundant for now...
                    //console.log(index + " | " + trailIndex);
                }
            }
            //console.log(twoDTextRainArray);


            //Iterate through time for leaders.
            function timeStep() {
                var index = 0
                //console.log(columnCount);
                //Update leader time passed
                for (index; index < columnCount; index++) {
                    //If time to shift text down, reset idle time, otherwise increase idle time
                    var textTimeIdle = twoDTextRainArray[index][0].getAttribute('idleTimeMS') * 1 + timeStepSizeMS;
                    var textUpdateTime = twoDTextRainArray[index][0].getAttribute('fallUpdateMS') * 1;
                    //console.log(index);
                    if (textTimeIdle >= textUpdateTime) {
                        //Reset idle time, move text & trail down.
                        twoDTextRainArray[index][0].setAttribute('idleTimeMS', 0);
                        textRainShift(index, textRainLengthsArray[index]);
                        //console.log(index);
                    } else {
                        //Increment idle time
                        twoDTextRainArray[index][0].setAttribute('idleTimeMS', textTimeIdle);
                    }

                }


            }

            function textRainShift(columnIndex, trailLength) {
                //Start from end of trail, and work towards leader.
                //console.log(columnIndex + " | " + trailLength);
                for (index = trailLength - 1; index > 0; index--) {
                    //Update position for trail element
                    var textAheadPos = twoDTextRainArray[columnIndex][index - 1].getAttribute('y') * 1;
                    twoDTextRainArray[columnIndex][index].setAttribute('y', textAheadPos);
                    //Update character - random
                    twoDTextRainArray[columnIndex][index].textContent = String.fromCharCode(Math.floor(Math.random() * 93) + 1);
                }

                //Have leader fall.
                //Update character - random
                twoDTextRainArray[columnIndex][0].textContent = String.fromCharCode(Math.floor(Math.random() * 93) + 1);
                //Update y position
                var nextLeaderYPos = twoDTextRainArray[columnIndex][0].getAttribute('y') * 1 + fallSpeed;

                //Determine whether to continue falling or restart.
                if ((nextLeaderYPos > (pageHeight * 5) / 6 && Math.random() > 0.9) || nextLeaderYPos > pageHeight) {
                    //Return to top of screen
                    twoDTextRainArray[columnIndex][0].setAttribute('y', Math.floor(Math.random() * -pageHeight));
                } else {
                    //Continue to fall
                    twoDTextRainArray[columnIndex][0].setAttribute('y', nextLeaderYPos);
                }
                //Update the canvas
                updateCanvas();

            }

            function updateCanvas() {
                //Background
                //svgTextRain.appendChild(rect);
                //Text characters
                var columnIndex = 0;

                for (columnIndex; columnIndex < columnCount; columnIndex++) {
                    //console.log(columnCount);
                    var trailIndex = 0
                    for (trailIndex; trailIndex < textRainLengthsArray[columnIndex]; trailIndex++) {
                        //Put text characters onto canvas
                        svgTextRain.appendChild(twoDTextRainArray[columnIndex][trailIndex]);
                        //console.log(columnIndex + " | " + trailIndex);
                    }

                }

                //Place onto webpage
                document.body.appendChild(svgTextRain);
            }


            //Bug testing function...
            function checkYPos() {
                for (leaderIndex = 0; leaderIndex < columnCount; leaderIndex++) {
                    console.log("Index " + leaderIndex + ", yPos:" + twoDTextRainArray[leaderIndex][0].getAttribute('y'))
                }

            }


            //How often the rain will update (ms)
            setInterval(timeStep, timeStepSizeMS);

            //setInterval(checkYPos, 10000);


        </script>

    </body>
</html>
